#' Graphic Display of Study Design Generated by finalize.nphDesign() Function
#' 
#' This function visualizes the following information: (1) Survival curves;
#' (2) Cumulative event curves; (3) Expected average hazard ratio curve; 
#' (4) Non-centrality parameter curves; (5) Projected z boundary curves; (6) Power curves; 
#' (7) Projected p value boundary curve for non-combination tests
#' 
#' @param nphDesign   nphDesign object generated by finalize.nphDesign() 
#' Function or explore.nphDesign function. In order to use this function,
#' must set show.setting = "Y" when calling finalize.nphDesign().
#' @param maxT  Maximum calendar time graphic display. Default 50 months.
#' 
#'  
#' @examples 
#' 
#' her2p.dist = list(
#' control = list(dist = "exponential", median = 6.7),
#' exp = list(HR = 6.7/12.5, delay = 6),
#' crossover = list(status = "N", HRx = NULL, Tx = NULL)
#' ) 
#' her2p.accr = list(
#'   A = 23,
#'   xi = 2,
#'   LTFU = 0
#' )
#' 
#' #recommend side = 1 for superiority design
#' #alpha takes priority than sf if alpha is provided.
#' #sf options: "LDOF", "LDPK"
#' her2p.alphabeta = list(
#'   sf = list(type = c("LDOF")),
#'   alpha = c(0.02, 0.03)/2,
#'   overall.alpha = 0.025,
#'   beta = 0.1,
#'   side = 1,
#'   timing = c(0.75, 1.0)
#' )
#' 
#' lr = function(s){1}
#' fh01 = function(s){1-s}
#' fh11 = function(s){s*(1-s)}
#' 
#' her2p.test = list(IA1 = list(lr), FA=list(lr, fh01))
#'  
#' her2p = finalize.nphDesign(T=c(29, 45.5), n=300, r=1, dist=her2p.dist, 
#'   accr=her2p.accr,alphabeta=her2p.alphabeta, f.ws = her2p.test,
#'   show.setting="Y")
#'  
#' display.nphDesign(nphDesign=her2p, maxT=50)
#'  
#' @export
#' 
display.nphDesign = function(nphDesign=D0.A18X1.W1, maxT=50){

  ##############
  #Extract the setting parameters from nphDesign object if provided
  ##############
  nph = f.extract(nphDesign)
  n = nph$N; A=nph$A;  w=nph$w; r=nph$r; 
  lambda0=nph$lam0; lambda1 = nph$lam1;
  cuts = nph$cuts; targetEvents = nph$targetEvents; 
  
  overall.alpha = nph$overall.alpha;
  side = nph$side; alpha = nph$alpha; f.ws = nph$fws

  h0 = nphDesign$design$setting$h0
  S0 = nphDesign$design$setting$S0  
  h1 = nphDesign$design$setting$h1
  S1 = nphDesign$design$setting$S1
  Fentry = nphDesign$design$setting$F.entry
  G.ltfu = nphDesign$design$setting$G.ltfu
  f.logHR = nphDesign$design$setting$log.HR
  
  #Number of analyses
  K = length(f.ws)
  J = lengths(f.ws) 
  timing = targetEvents/targetEvents[K]
  
  #(1) Accrual curve
  t = seq(0, A, by = 1)
  cum.enroll = Fentry(t)
  plot(t, cum.enroll, type="l", lwd=3, xlab = "Calendar Time", ylab="Cumulative Accrual")
  abline(v=seq(0, A, 1), col="gray80", lty=3)
  abline(h=seq(0, 1, 0.1), col="gray80", lty=3)
  
  #(2) Display distributions
  plot_S(S=list(S0, S1), Tmax = maxT)
  
  #(3) Display cumulative events over time
  plot_events(Tmax = maxT, r=r, h0=h0, S0=S0, h1=h1, S1=S1, 
              F.entry = Fentry, G.ltfu = G.ltfu, n = n)
  
  #(4) Display Expected Average hazard ratio over calendar time
  plot_AHR(r = r, n =n, h0 = h0, S0=S0, h1 = h1, S1=S1, f.logHR = f.logHR,
           rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
           F.entry = Fentry, G.ltfu = G.ltfu, Tmax=maxT)
  
  #(5) Non-centrality parameter curves
  plot_wlr.mu (Tmax = maxT, r = r, n = n,h0 = h0, S0= S0, h1 = h1, S1=S1, 
               f.logHR = f.logHR, fws = f.ws[[K]], F.entry = Fentry, G.ltfu = G.ltfu)
  
  #(6) Projected z boundary curves
  plot(nphDesign$design$events$events, nphDesign$design$bounds[,1], type="b", lwd=2, 
       xlab = "Analysis Timing Based on Events", ylab = "z Rejection boundary", 
       main = "Projected Rejection Boundary (Z)")
  abline(v = seq(0, nphDesign$design$events$events[K]*2, 10), col="gray80", lty=3)
  abline(h = seq(0, 10, 0.05), col="gray80", lty=3)

  e0 =   nphDesign$design$events$events[K]
  #(7) Power curve vs events 
  e.seq = seq(max(10, e0/50), min(e0*1.2, n*0.85), length.out = 30)
  overall.pow.seq = rep(NA, length(e.seq))
  pow.seq = matrix(NA, nrow=length(e.seq), ncol=K)
  
  for (i in 1:length(e.seq)){
    wlr.seq = wlr.power.maxcombo(T = NULL, events = e.seq[i] * timing, 
                          alpha = alpha, power = NULL, side = side, r = r, n = n, 
                          h0 = h0, S0=S0, h1 = h1, S1= S1, f.logHR = f.logHR, 
                          f.ws = f.ws, F.entry=Fentry, G.ltfu=G.ltfu)
    overall.pow.seq[i] = wlr.seq$overall.power
    pow.seq[i,] = wlr.seq$power
  }
  #Overall power
  plot(e.seq, overall.pow.seq, type="l", lwd=3, xlab="Number of Events at Final Analysis", 
       ylab="Power", main="Overall Power")
  
  abline(h = seq(0, 1, 0.05), col="gray80", lty=3)
  abline(v = seq(0, max(e.seq), by=10), col="gray80", lty=3)
  
  abline(v=e0*timing, col="green", lwd=3)
  
  #Power of each analysis
  for(j in 1:K){
    plot(e.seq*timing[j], pow.seq[,j], type="l", lwd=3, xlab = paste("Number of Events at Analysis", j), 
         ylab="Power", main=paste("Power of analysis", j))
    
    abline(h = seq(0, 1, 0.05), col="gray80", lty=3)
    abline(v = seq(0, max(e.seq*timing[j]), by=10), col="gray80", lty=3)
    
    abline(v=e0*timing[j], col="green", lwd=3)
  }
  
  #(8) P-value boundary for non-combination test at each analysis
  if (sum(J) == K){
    if(side == 1){
      p.bd = 1 - pnorm(nphDesign$design$bounds[,1])
    }
    if (side == 2){
      p.bd = 2*(1 - pnorm(nphDesign$design$bounds[,1]))
    }
    plot(nphDesign$design$events$events, p.bd, type="b", lwd=2, 
         xlab = "Analysis Timing Based on Events", ylab="P value", 
         main = "Projected Rejection Boundary (p-value)")
    abline(v = seq(0, nphDesign$design$events$events[K]*2, 10), col="gray80", lty=3)
    abline(h = seq(0, 1, 0.001), col="gray80", lty=3)
  }
  
}
